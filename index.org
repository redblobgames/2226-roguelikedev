#+title: Roguelike Dev
#+date: <2022-06-28 Tue>
#+options: toc:nil

Each summer r/roguelikedev has a [[https://old.reddit.com/r/roguelikedev/wiki/python_tutorial_series][summer event]] in which we all make a simple roguelike, roughly following the libtcod roguelike tutorial. I've tried several times and [[href:/x/2025-roguelike-dev/][actually finished in 2020]], using [[https://ondras.github.io/rot.js/hp/][rot.js]] and Javascript. I kept the scope down by implementing only the topics from the tutorial. Then [[href:/x/2126-roguelike-dev/][in 2021]] I implemented topics I wanted to try: thin walls, graphics, animations, openable doors, new map generator. I had many more things I wanted to try but I was too ambitious, and didn't finish.

For this year's summer event I'd like to do something more "fortress mode" and less "adventure mode".  This may prove too ambitious; we shall see.

#+include: "game.html" export html

Icons from [[https://game-icons.net][game-icons.net]], CC BY 3.0. Code repository [[https://github.com/redblobgames/2226-roguelikedev][on github]].

#+TOC: headlines 2

* Setting up
:PROPERTIES:
:UNNUMBERED: t
:SECTION_NUMBER: 0
:CUSTOM_ID: setting-up
:END:

Compared to a Python project, I feel the set up is simpler in Javascript. I started with =game.html=:

#+begin_src xml
<canvas id="game" width="660" height="660" />
<script src="build/_bundle.js"></script>
#+end_src

If I were using rot.js, there's be one more =<script>= line. This year I'm not using rot.js. I'm using Typescript instead of Javascript. Here's =roguelike-dev.ts=:

#+begin_src typescript
const canvas = document.querySelector("#game") 
               as HTMLCanvasElement;
#+end_src

The Typescript file has to be compiled into Javascript before the browser will run it. I've been using [[https://esbuild.github.io/][esbuild]] for that. I really like it. I have lots of small projects and have standardized on having a file called ~./build.sh~ that will build the project:

#+begin_src sh
#!/bin/sh
mkdir -p build/
esbuild roguelike-dev.ts --bundle --outfile=build/_bundle.js
#+end_src

There's a [[https://devblogs.microsoft.com/typescript/a-proposal-for-type-syntax-in-javascript/][proposal to allow but ignore types in Javascript's syntax]], similar to what Python does. If that passes, then I won't need this build step. But it only takes 0.06 seconds to run and I run it automatically on file save so it's only a minor annoyance right now.

For the rest of this project I'm going to /try/ to follow the same section numbers as the original Python tutorial and the r/roguelikedev summer event, but some topics won't make sense in fortress mode so I will do something else instead.

* Moving around
:PROPERTIES:
:CUSTOM_ID: section-1
:END:

** Rendering
:PROPERTIES:
:CUSTOM_ID: rendering
:END:

I'm using =<canvas>= this year, not =<svg>=. Conveniently, the game-icons svg icons are all a /single/ =<path>=, and paths can be drawn to a =<canvas>= using [[https://developer.mozilla.org/en-US/docs/Web/API/Path2D][Path2D]]. To load the icon into memory, I can use esbuild's loaders to make importing an svg work:

#+begin_src js
import person from "./game-icons/delapouite/person.svg";
#+end_src

#+begin_src sh
esbuild --loader:.svg=text
#+end_src

This will make =person= the contents of the svg file.

Given a Path2D I can draw using any fill and outline style I want (including gradients, line widths, and shadows). I imported sprites in but I somewhere I need to store what style to draw them in. WebGL would open up more possibilities but I'm trying to follow [[https://wiki.c2.com/?DoTheSimplestThingThatCouldPossiblyWork][DoTheSimplestThingThatCouldPossiblyWork]] so I'm going to stick to regular =<canvas>=.

** Keyboard
:PROPERTIES:
:CUSTOM_ID: keyboard
:END:

For the keyboard I'm mostly following what I did [[href:/x/2025-roguelike-dev/#key-input][two years ago]]. I add a =tabindex= to the =<canvas>= to allow it to receive keyboard focus. When it doesn't have focus, I display a message telling the player to click on the game to give it focus. I think the alternative is to make the entire window's keyboard events go to the game, but I like this approach better because it allows me to use the arrow keys for scrolling the page, or use an =<input>= box that receives keyboard focus.

When the canvas has keyboard focus it will get =keydown= events with each key pressed. I might want to get both =keyup= and =keydown= because I think it might be useful for building to hold down a direction key and then press a letter to build something in that direction. I'll experiment with that when I get to building.

* Entity, render, map
:PROPERTIES:
:CUSTOM_ID: section-2
:END:

** Entities
:PROPERTIES:
:CUSTOM_ID: entities
:END:

I made an Entity class just like in [[https://rogueliketutorials.com/tutorials/tcod/v2/part-2/][the Python tutorial]], but with two changes:

1. I changed =x= and =y= being separate fields to a single Location object ={x, y}=. This is because I want to be able to pass the location around and also have special values like "not on the map" or "in inventory". I will later extend Location to be an enum to hold special values.
2. I changed =char= and =color= being their own fields to a single Appearance object ={sprite}=. I think the sprite characteristics should not be per-entity, but stored elsewhere. I'll then extend Appearance to have modifiers to override the color, size, etc. per entity.

#+begin_src typescript
export type Location = {x: number, y: number};
export type Appearance = {sprite: string};

export class Entity {
    constructor (public location: Location, 
                 public appearance: Appearance) {
    }

    moveBy(dx: number, dy: number) {
        this.location = {x: this.location.x + dx,
                         y: this.location.y + dy};
    }
}
#+end_src

** Engine
:PROPERTIES:
:CUSTOM_ID: engine
:END:

As Python and Javascript modules act like objects, I didn't see a strong need to make an =Engine= class just yet. The fields of the Engine in the Python tutorial become module-level variables in my project. If there's a need (either to have multiple instances, or to pass it around to other modules), I'll change it later.

** Map
:PROPERTIES:
:CUSTOM_ID: map-storage
:END:

The [[https://rogueliketutorials.com/tutorials/tcod/v2/part-2/][Python tutorial]] for the map goes into NumPy =dtype= and =ndarray=, but I don't need that in Javascript. I'm also not planning to have FOV in this project, so I don't need the =transparent= and =dark= data. What do I actually need?

1. A =GameMap= will have an array of tiles.
1. The tile will be static data (the same for every instance of that tile: appearance, properties like walkability, etc.) and varying data (only the tile type right now, but maybe more later like water depth)

So I think for now the =GameMap= can be an array of strings, and the strings will be a index into the static data.

I put in some dummy data for now to test my renderer. Generating the map will be the next section.

#+begin_export html
<figure>
  <img src="screenshots/section-1-player.png" />
  <figcaption>Dummy data for rendering</figcaption>
</figure>
#+end_export


* TODO Generating a map
:PROPERTIES:
:CUSTOM_ID: generating-a-map
:END:

** Terrain generation
:PROPERTIES:
:CUSTOM_ID: map-terrain-generation
:END:

Since I'm making a "fortress style" game, I want the main map to be a /wilderness/ map with resources that you can use to /build/ your own settlement. What terrain do I want to start with?

1. one river going through the map
1. grassland near the river
1. desert away from the river
1. mountains somewhere

I will start by drawing a meandering river through the map, and then define the other elements by how far they are from the river. Will that be a reasonable starting point? We'll see.

#+begin_export html
<figure>
  <img src="screenshots/section-2-map.png" />
  <figcaption>Map with meandering river</figcaption>
</figure>
#+end_export

Ok, I think it's a reasonable river. Let's add some terrain near it:

#+begin_export html
<figure>
  <img src="screenshots/section-3a-map.png" />
  <figcaption>Map with river, grass, desert, with pattern textures</figcaption>
</figure>
#+end_export

I started thinking about sprite graphics. I might want the same sprite /shape/ but different /color/ to mean different things. Some sprites should be smaller than the full tile. And there will be mobile objects like animals drawn on top of static objects like trees drawn on top of terrain floors. I think that's a lot of information on a tile. I decided to change the floors to flat squares to make it easier to see the foreground objects:

#+begin_export html
<figure>
  <img src="screenshots/section-3b-map.png" />
  <figcaption>Map with flat textures</figcaption>
</figure>
#+end_export

I also decided that the starting point will be the west side of the map, with grass and a river. Then to the east will be a desert, and then mountains. This will create a "left to right" game flow as you level up and dig deeper for more minerals.

** Scrolling
:PROPERTIES:
:CUSTOM_ID: map-scrolling
:END:

I also need to make the map a bit bigger to have room for both wilderness and building. Since the map will be bigger than what's on the screen, I need to have scrolling. Normally in a "fortress style" game you'd scroll with the mouse or with dragging, but since I still have a player character walking around, I made it scroll with the player character. To center the view on the player, wherever I'm drawing to the window with:

#+begin_src js
display.draw(x, y, ch, color);
#+end_src

I need to instead /offset/ that position:

#+begin_src js
display.draw(x - player.location.x + WINDOW_WIDTH/2, 
             y - player.location.y + WINDOW_HEIGHT/2, 
             ch, color);
#+end_src

The way to think of this is in two steps:

1. Subtracting the player position moves the player to 0,0
2. Adding the width/2, height/2 moves from 0,0 to the center of the screen

A bonus would be to have a /camera/ that's separate from the /player/. Let's do that:

#+begin_src js
let camera = {x: player.location.x, y: player.location.y};

…
camera.x = player.location.x;
camera.y = player.location.y;
…
display.draw(x - camera.x + WINDOW_WIDTH/2, 
             y - camera.y + WINDOW_HEIGHT/2, 
             ch, color);
#+end_src

Ok, it's a separate object now but it's always pointed at the player. Let's change it so that it follows the player but can be behind by 2 tiles:

#+begin_src js
camera.x = clamp(camera.x, 
                 player.location.x - 2, 
                 player.location.x + 2);
camera.y = clamp(camera.y, 
                 player.location.y - 2, 
                 player.location.y + 2);
#+end_src

We can also make it stop scrolling before reaching the end of the map:

#+begin_src js
const halfwidth = VIEWWIDTH >> 1;
const halfheight = VIEWHEIGHT >> 1;
camera.x = clamp(camera.x,
                 map.bounds.left + halfwidth,
                 map.bounds.right - halfwidth+ 1);
camera.y = clamp(camera.y,
                 map.bounds.top + halfheight,
                 map.bounds.bottom - halfheight + 1);
#+end_src

I think there are more fun things that I could do but I'll leave that for later.

** TODO Resource placement
:PROPERTIES:
:CUSTOM_ID: map-resources
:END:

In addition to the /floor/ types (grass, desert, water) I also want to place objects on top: trees, stones, berries, gems.

** TODO Building
:PROPERTIES:
:CUSTOM_ID: map-building
:END:

The generated map is only the wilderness. In this game the player will be building the rooms. I need to figure out the UI for that. If I had a /facing/ direction then the player could build in front of themselves. My first idea was to have you /pick up/ building materials and then /place/ them for building. But the keystrokes for that are annoying. If you want to build a wall on tiles 1, 2, 3:

#+begin_example
  1  2  3
  4  5  6
#+end_example

You have to first pick up the stone, then move to 4, press ~Up~ to face towards 1, press ~E~ to build, then press ~Right~ to face right, then press ~Right~ to move right, then press ~Up~ to face towards towards 2, press ~E~ to build, etc.

It'd be simpler if you didn't have to pick up the materials, but that's not the real problem. It's three keystrokes per tile. I want to reduce the number of keystrokes per tile.

The next idea was to have a build key ~B~ to switch to build mode, like vim's insert vs normal mode. In build mode you can move the cursor around freely to build things. Then press ~B~ again to go back to the player mode. What are the keys in build mode? I guess you'd have to choose what to build: ~W~ for wall, ~S~ for stockpile, etc. In the example, you would move to 4, press ~B~ to switch modes, then ~Up~ to move to 1, ~W~ for wall, ~Right~ to move to 2, ~W~ for wall, ~Right~ to move to 3, ~W~ for wall, then ~B~ to exit build mode, which would return you back to the player at 4.

This is two keystrokes per tile.

The next idea was to have commands inside build mode. In the example, you would move to 4, press ~B~ to start build mode, ~W~ to start wall-building mode, then ~Up~ to move to 1 and build a wall there, then ~Right~ to move to 2 and build there, then ~Right~ to move to 3 and build there, then ~W~ to exit wall-building mode, then ~B~ to exit build mode, which would return you back to the player at 4.

This is down to one keystroke per tile. Other modes like stockpile-drawing mode might use arrow keys to mark a rectangle instead of a line. And others like placing an object might use one or two keystrokes to choose the object, but then return you to build mode. It's looking like this:

#+begin_export html
<figure>
  <img src="screenshots/build-mode-idea-3.png" />
  <figcaption>Player and build and specialized modes</figcaption>
</figure>
#+end_export

It'd be simpler if you could directly go into wall-building mode by pressing ~W~ from the player mode. But that means you can't start a wall anywhere, but only next to where the player can walk. So I still need build mode to be able to choose where to start the wall.

Stepping back a bit, I had been starting from the "adventure mode" style movement for your player character, but I have to admit, I haven't come up with any ideas for what you'd actually /do/ in player mode. So maybe I should drop player mode, and treat build mode as the normal mode. Then you'd press the verb (~W~ for walls, ~S~ for stockpiles, ~D~ for doors, etc.) which would take you into a specialized mode for creating that type of object, and then you'd return to the main mode to move around.

I think this means I can't use the [[https://simblob.blogspot.com/2019/10/verb-noun-vs-noun-verb.html][noun-verb approach]] I wanted to try last year. Traditional roguelikes use verb-noun, where you choose the action first and then you choose the object. You might choose throw, and then choose from a list of throwable items. With noun-verb you first select an object and then you pick the action to apply. You might first choose a potion and then the action could be throw or drink. Modern games, modern programming languages, and modern UIs typically use noun-verb. For example in a text editor, you first select some text and then you pick an action like cut. Since I want a different UI depending on which verb is used, I think I have to use verb-noun instead of noun-verb.

Other thoughts: Should I switch to the mouse? Dragging a line or rectangle probably makes more sense with a mouse. But I want to see how far I can get with the keyboard. I should also take another look at [[https://dwarffortresswiki.org/index.php/DF2014:Controls][Dwarf Fortress keys]].

* TODO Field of view
:PROPERTIES:
:CUSTOM_ID: section-4
:END:

1. no field of view; you can see everything? but maybe mountain tiles are limited to only adjacent to dug-out areas
1. scrolling map

* TODO Placing enemies
:PROPERTIES:
:CUSTOM_ID: section-5
:END:

1. there will be friendly npcs
1. I need lots of pathfinding

* TODO Combat
:PROPERTIES:
:CUSTOM_ID: section-6
:END:

1. not sure if I'll have combat at all

* TODO Interface
:PROPERTIES:
:CUSTOM_ID: section-7
:END:

* TODO Items and inventory
:PROPERTIES:
:CUSTOM_ID: section-8
:END:

1. individual inventory, or everything owned by the colony?

* TODO Ranged scrolls and targeting
:PROPERTIES:
:CUSTOM_ID: section-9
:END:

1. maybe planting and harvesting instead

* TODO Saving and loading
:PROPERTIES:
:CUSTOM_ID: section-10
:END:

1. probably will skip

* TODO Dungeon levels
:PROPERTIES:
:CUSTOM_ID: section-11
:END:

1. not applicable, need to find another topic for this week

* TODO Increasing difficulty
:PROPERTIES:
:CUSTOM_ID: section-12
:END:

1. want you to have to learn more systems as you scale up (more people or more advanced tech)

* TODO Gearing up
:PROPERTIES:
:CUSTOM_ID: section-13
:END:

1. not applicable, need to find another topic for this week

* TODO Conclusion

#+begin_export html
<x:footer>
  Created 28 Jun 2022; &#160;
  <!-- hhmts start -->Last modified: 09 Jul 2022<!-- hhmts end -->
</x:footer>
#+end_export
