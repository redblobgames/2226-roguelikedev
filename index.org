#+title: Roguelike Dev
#+date: <2022-06-28 Tue>
#+options: toc:nil

Each summer r/roguelikedev has a [[https://old.reddit.com/r/roguelikedev/wiki/python_tutorial_series][summer event]] in which we all make a simple roguelike, roughly following the libtcod roguelike tutorial. I've tried several times and [[href:/x/2025-roguelike-dev/][actually finished in 2020]], using [[https://ondras.github.io/rot.js/hp/][rot.js]] and Javascript. I kept the scope down by implementing only the topics from the tutorial. Then [[href:/x/2126-roguelike-dev/][in 2021]] I implemented topics I wanted to try: thin walls, graphics, animations, openable doors, new map generator. I had many more things I wanted to try but I was too ambitious, and didn't finish.

For this year's summer event I'd like to do something more "fortress mode" and less "adventure mode".  This may prove too ambitious; we shall see.

#+include: "game.html" export html

Icons from [[https://game-icons.net][game-icons.net]], CC BY 3.0. Code repository [[https://github.com/redblobgames/2226-roguelikedev][on github]].

#+TOC: headlines 2

* Setting up
:PROPERTIES:
:UNNUMBERED: t
:SECTION_NUMBER: 0
:CUSTOM_ID: setting-up
:END:

Compared to a Python project, I feel the set up is simpler in Javascript. I started with =game.html=:

#+begin_src xml
<canvas id="game" width="660" height="660" />
<script src="build/_bundle.js"></script>
#+end_src

If I were using rot.js, there's be one more =<script>= line. This year I'm not using rot.js. I'm using Typescript instead of Javascript. Here's =roguelike-dev.ts=:

#+begin_src typescript
const canvas = document.querySelector("#game") 
               as HTMLCanvasElement;
#+end_src

The Typescript file has to be compiled into Javascript before the browser will run it. I've been using [[https://esbuild.github.io/][esbuild]] for that. I really like it. I have lots of small projects and have standardized on having a file called ~./build.sh~ that will build the project:

#+begin_src sh
#!/bin/sh
mkdir -p build/
esbuild roguelike-dev.ts --bundle --outfile=build/_bundle.js
#+end_src

There's a [[https://devblogs.microsoft.com/typescript/a-proposal-for-type-syntax-in-javascript/][proposal to allow but ignore types in Javascript's syntax]], similar to what Python does. If that passes, then I won't need this build step. But it only takes 0.06 seconds to run and I run it automatically on file save so it's only a minor annoyance right now.

For the rest of this project I'm going to /try/ to follow the same section numbers as the original Python tutorial and the r/roguelikedev summer event, but some topics won't make sense in fortress mode so I will do something else instead.

* Moving around
:PROPERTIES:
:CUSTOM_ID: section-1
:END:

** Rendering
:PROPERTIES:
:CUSTOM_ID: rendering
:END:

I'm using =<canvas>= this year, not =<svg>=. Conveniently, the game-icons svg icons are all a /single/ =<path>=, and paths can be drawn to a =<canvas>= using [[https://developer.mozilla.org/en-US/docs/Web/API/Path2D][Path2D]]. To load the icon into memory, I can use esbuild's loaders to make importing an svg work:

#+begin_src js
import person from "./game-icons/delapouite/person.svg";
#+end_src

#+begin_src sh
esbuild --loader:.svg=text
#+end_src

This will make =person= the contents of the svg file.

Given a Path2D I can draw using any fill and outline style I want (including gradients, line widths, and shadows). I imported sprites in but I somewhere I need to store what style to draw them in. WebGL would open up more possibilities but I'm trying to follow [[https://wiki.c2.com/?DoTheSimplestThingThatCouldPossiblyWork][DoTheSimplestThingThatCouldPossiblyWork]] so I'm going to stick to regular =<canvas>=.

** Keyboard
:PROPERTIES:
:CUSTOM_ID: keyboard
:END:

For the keyboard I'm mostly following what I did [[href:/x/2025-roguelike-dev/#key-input][two years ago]]. I add a =tabindex= to the =<canvas>= to allow it to receive keyboard focus. When it doesn't have focus, I display a message telling the player to click on the game to give it focus. I think the alternative is to make the entire window's keyboard events go to the game, but I like this approach better because it allows me to use the arrow keys for scrolling the page, or use an =<input>= box that receives keyboard focus.

When the canvas has keyboard focus it will get =keydown= events with each key pressed. I might want to get both =keyup= and =keydown= because I think it might be useful for building to hold down a direction key and then press a letter to build something in that direction. I'll experiment with that when I get to building.

* Entity, render, map
:PROPERTIES:
:CUSTOM_ID: section-2
:END:

** Entities
:PROPERTIES:
:CUSTOM_ID: entities
:END:

I made an Entity class just like in [[https://rogueliketutorials.com/tutorials/tcod/v2/part-2/][the Python tutorial]], but with two changes:

1. I changed =x= and =y= being separate fields to a single Location object ={x, y}=. This is because I want to be able to pass the location around and also have special values like "not on the map" or "in inventory". I will later extend Location to be an enum to hold special values.
2. I changed =char= and =color= being their own fields to a single Appearance object ={sprite}=. I think the sprite characteristics should not be per-entity, but stored elsewhere. I'll then extend Appearance to have modifiers to override the color, size, etc. per entity.

#+begin_src typescript
export type Location = {x: number, y: number};
export type Appearance = {sprite: string};

export class Entity {
    constructor (public location: Location, 
                 public appearance: Appearance) {
    }

    moveBy(dx: number, dy: number) {
        this.location = {x: this.location.x + dx,
                         y: this.location.y + dy};
    }
}
#+end_src

** Engine
:PROPERTIES:
:CUSTOM_ID: engine
:END:

As Python and Javascript modules act like objects, I didn't see a strong need to make an =Engine= class just yet. The fields of the Engine in the Python tutorial become module-level variables in my project. If there's a need (either to have multiple instances, or to pass it around to other modules), I'll change it later.

** Map
:PROPERTIES:
:CUSTOM_ID: map-storage
:END:

The [[https://rogueliketutorials.com/tutorials/tcod/v2/part-2/][Python tutorial]] for the map goes into NumPy =dtype= and =ndarray=, but I don't need that in Javascript. I'm also not planning to have FOV in this project, so I don't need the =transparent= and =dark= data. What do I actually need?

1. A =GameMap= will have an array of tiles.
1. The tile will be static data (the same for every instance of that tile: appearance, properties like walkability, etc.) and varying data (only the tile type right now, but maybe more later like water depth)

So I think for now the =GameMap= can be an array of strings, and the strings will be a index into the static data.

I put in some dummy data for now. Generating the map will be the next section.

* TODO Generating a map
:PROPERTIES:
:CUSTOM_ID: generating-a-map
:END:

** Generation
:PROPERTIES:
:CUSTOM_ID: map-generation
:END:

Since I'm making a "fortress style" game, I want the main map to be a /wilderness/ map with resources that you can use to /build/ your own settlement. What terrain do I want to start with?

1. one river going through the map
1. grassland near the river
1. desert away from the river
1. mountains somewhere

I will start by drawing a meandering river through the map, and then define the other elements by how far they are from the river. Will that be a reasonable starting point? We'll see.

Tangent: the same sprite in different colors could mean different things. So far my code loads a /sprite/ but then hard codes the colors. I'll need a mapping from tile type to sprite+color.

** Scrolling
:PROPERTIES:
:CUSTOM_ID: map-scrolling
:END:

I also need to make the map a bit bigger to have room for both wilderness and building. Since the map will be bigger than what's on the screen, I need to have scrolling. Normally in a "fortress style" game you'd scroll with the mouse or with dragging, but since I still have a player character walking around, I made it scroll with the player character. To center the view on the player, wherever I'm drawing to the window with:

#+begin_src js
display.draw(x, y, ch, color);
#+end_src

I need to instead /offset/ that position:

#+begin_src js
display.draw(x - player.x + WINDOW_WIDTH/2, 
             y - player.y + WINDOW_HEIGHT/2, 
             ch, color);
#+end_src

The way to think of this is in two steps:

1. Subtracting the player position moves the player to 0,0
2. Adding the width/2, height/2 moves from 0,0 to the center of the screen

* TODO Field of view
:PROPERTIES:
:CUSTOM_ID: section-4
:END:

1. no field of view; you can see everything
1. scrolling map

* TODO Placing enemies
:PROPERTIES:
:CUSTOM_ID: section-5
:END:

1. there will be friendly npcs


* TODO Combat
:PROPERTIES:
:CUSTOM_ID: section-6
:END:

1. not sure if I'll have combat at all

* TODO Interface
:PROPERTIES:
:CUSTOM_ID: section-7
:END:

* TODO Items and inventory
:PROPERTIES:
:CUSTOM_ID: section-8
:END:

1. individual inventory, or everything owned by the colony?

* TODO Ranged scrolls and targeting
:PROPERTIES:
:CUSTOM_ID: section-9
:END:

1. maybe planting and harvesting instead

* TODO Saving and loading
:PROPERTIES:
:CUSTOM_ID: section-10
:END:

1. probably will skip

* TODO Dungeon levels
:PROPERTIES:
:CUSTOM_ID: section-11
:END:

1. not applicable, need to find another topic for this week

* TODO Increasing difficulty
:PROPERTIES:
:CUSTOM_ID: section-12
:END:

1. want you to have to learn more systems as you scale up (more people or more advanced tech)

* TODO Gearing up
:PROPERTIES:
:CUSTOM_ID: section-13
:END:

1. not applicable, need to find another topic for this week

* TODO Conclusion

#+begin_export html
<x:footer>
  Created 28 Jun 2022; &#160;
  <!-- hhmts start -->Last modified: 06 Jul 2022<!-- hhmts end -->
</x:footer>
#+end_export
