#+title: Roguelike Dev
#+date: <2022-06-28 Tue>
#+options: toc:nil

Each summer r/roguelikedev has a [[https://old.reddit.com/r/roguelikedev/wiki/python_tutorial_series][summer event]] in which we all make a simple roguelike, roughly following the libtcod roguelike tutorial. I've tried several times and [[href:/x/2025-roguelike-dev/][actually finished in 2020]], using [[https://ondras.github.io/rot.js/hp/][rot.js]] and Javascript. I kept the scope down by implementing only the topics from the tutorial. Then [[href:/x/2126-roguelike-dev/][in 2021]] I implemented topics I wanted to try: thin walls, graphics, animations, openable doors, new map generator. I had many more things I wanted to try but I was too ambitious, and didn't finish.

For this year's summer event I'd like to do something more "fortress mode" and less "adventure mode".  This may prove too ambitious; we shall see. This project for me is not about making a complete, fun, polished game. It's about exploring what a "fortress mode" game might involve.

#+include: "game.html" export html

Icons from [[https://game-icons.net][game-icons.net]], CC BY 3.0. Code repository [[https://github.com/redblobgames/2226-roguelikedev][on github]].

#+TOC: headlines 2

* Setting up
:PROPERTIES:
:UNNUMBERED: t
:SECTION_NUMBER: 0
:CUSTOM_ID: 0-setting-up
:END:

Compared to a Python project, I feel the set up is simpler in Javascript. I started with =game.html=:

#+begin_src xml
<canvas id="game" width="660" height="660" />
<script src="build/_bundle.js"></script>
#+end_src

If I were using rot.js, there's be one more =<script>= line. This year I'm not using rot.js. I'm using Typescript instead of Javascript. Here's =roguelike-dev.ts=:

#+begin_src typescript
const canvas = document.querySelector("#game") 
               as HTMLCanvasElement;
#+end_src

The Typescript file has to be compiled into Javascript before the browser will run it. I've been using [[https://esbuild.github.io/][esbuild]] for that. I really like it. I have lots of small projects and have standardized on having a file called ~./build.sh~ that will build the project:

#+begin_src sh
#!/bin/sh
mkdir -p build/
esbuild roguelike-dev.ts --bundle --outfile=build/_bundle.js
#+end_src

There's a [[https://devblogs.microsoft.com/typescript/a-proposal-for-type-syntax-in-javascript/][proposal to allow but ignore types in Javascript's syntax]], similar to what Python does. If that passes, then I won't need this build step. But it only takes 0.06 seconds to run and I run it automatically on file save so it's only a minor annoyance right now.

For the rest of this project I'm going to /try/ to follow the same section numbers as the original Python tutorial and the r/roguelikedev summer event, but some topics won't make sense in fortress mode so I will do something else instead.

* Moving around
:PROPERTIES:
:CUSTOM_ID: section-1
:END:

** Rendering
:PROPERTIES:
:CUSTOM_ID: 1-rendering
:END:

I'm using =<canvas>= this year, not =<svg>=. Conveniently, the game-icons svg icons are all a /single/ =<path>=, and paths can be drawn to a =<canvas>= using [[https://developer.mozilla.org/en-US/docs/Web/API/Path2D][Path2D]]. To load the icon into memory, I can use esbuild's loaders to make importing an svg work:

#+begin_src js
import person from "./game-icons/delapouite/person.svg";
#+end_src

#+begin_src sh
esbuild --loader:.svg=text
#+end_src

This will make =person= the contents of the svg file.

Given a Path2D I can draw using any fill and outline style I want (including gradients, line widths, and shadows). I imported sprites in but I somewhere I need to store what style to draw them in. WebGL would open up more possibilities but I'm trying to follow [[https://wiki.c2.com/?DoTheSimplestThingThatCouldPossiblyWork][DoTheSimplestThingThatCouldPossiblyWork]] so I'm going to stick to regular =<canvas>=.

** Keyboard
:PROPERTIES:
:CUSTOM_ID: 1-keyboard
:END:

For the keyboard I'm mostly following what I did [[href:/x/2025-roguelike-dev/#key-input][two years ago]]. I add a =tabindex= to the =<canvas>= to allow it to receive keyboard focus. When it doesn't have focus, I display a message telling the player to click on the game to give it focus. I think the alternative is to make the entire window's keyboard events go to the game, but I like this approach better because it allows me to use the arrow keys for scrolling the page, or use an =<input>= box that receives keyboard focus.

When the canvas has keyboard focus it will get =keydown= events with each key pressed. I might want to get both =keyup= and =keydown= because I think it might be useful for building to hold down a direction key and then press a letter to build something in that direction. I'll experiment with that when I get to building.

* Entity, render, map
:PROPERTIES:
:CUSTOM_ID: section-2
:END:

** Entities
:PROPERTIES:
:CUSTOM_ID: 2-entities
:END:

I made an Entity class just like in [[https://rogueliketutorials.com/tutorials/tcod/v2/part-2/][the Python tutorial]], but with two changes:

1. I changed =x= and =y= being separate fields to a single Location object ={x, y}=. This is because I want to be able to pass the location around and also have special values like "not on the map" or "in inventory". I will later extend Location to be an enum to hold special values.
2. I changed =char= and =color= being their own fields to a single Appearance object ={sprite}=. I think the sprite characteristics should not be per-entity, but stored elsewhere. I'll then extend Appearance to have modifiers to override the color, size, etc. per entity.

#+begin_src typescript
export type Location = {x: number, y: number};
export type Appearance = {sprite: string};

export class Entity {
    constructor (public location: Location, 
                 public appearance: Appearance) {
    }

    moveBy(dx: number, dy: number) {
        this.location = {x: this.location.x + dx,
                         y: this.location.y + dy};
    }
}
#+end_src

** Engine
:PROPERTIES:
:CUSTOM_ID: 2-engine
:END:

As Python and Javascript modules act like objects, I didn't see a strong need to make an =Engine= class just yet. The fields of the Engine in the Python tutorial become module-level variables in my project. If there's a need (either to have multiple instances, or to pass it around to other modules), I'll change it later.

** Map
:PROPERTIES:
:CUSTOM_ID: 2-map-storage
:END:

The [[https://rogueliketutorials.com/tutorials/tcod/v2/part-2/][Python tutorial]] for the map goes into NumPy =dtype= and =ndarray=, but I don't need that in Javascript. I'm also not planning to have FOV in this project, so I don't need the =transparent= and =dark= data. What do I actually need?

1. A =GameMap= will have an array of tiles.
1. The tile will be static data (the same for every instance of that tile: appearance, properties like walkability, etc.) and varying data (only the tile type right now, but maybe more later like water depth)

So I think for now the =GameMap= can be an array of strings, and the strings will be a index into the static data.

I put in some dummy data for now to test my renderer. Generating the map will be the next section.

#+begin_export html
<figure>
  <img src="screenshots/section-1-player.png" />
  <figcaption>Dummy data for rendering</figcaption>
</figure>
#+end_export


* Generating a map
:PROPERTIES:
:CUSTOM_ID: section-3
:END:

** Terrain generation
:PROPERTIES:
:CUSTOM_ID: 3-map-terrain-generation
:END:

Since I'm making a "fortress style" game, I want the main map to be a /wilderness/ map with resources that you can use to /build/ your own settlement. What terrain do I want to start with?

1. one river going through the map
1. grassland near the river
1. desert away from the river
1. mountains somewhere

I will start by drawing a meandering river through the map, and then define the other elements by how far they are from the river. Will that be a reasonable starting point? We'll see.

#+begin_export html
<figure>
  <img src="screenshots/section-2-map.png" />
  <figcaption>Map with meandering river</figcaption>
</figure>
#+end_export

Ok, I think it's a reasonable river. Let's add some terrain near it:

#+begin_export html
<figure>
  <img src="screenshots/section-3a-map.png" />
  <figcaption>Map with river, grass, desert, with pattern textures</figcaption>
</figure>
#+end_export

I started thinking about sprite graphics. I might want the same sprite /shape/ but different /color/ to mean different things. Some sprites should be smaller than the full tile. And there will be mobile objects like animals drawn on top of static objects like trees drawn on top of terrain floors. I think that's a lot of information on a tile. I decided to change the floors to flat squares to make it easier to see the foreground objects:

#+begin_export html
<figure>
  <img src="screenshots/section-3b-map.png" />
  <figcaption>Map with flat textures</figcaption>
</figure>
#+end_export

I also decided that the starting point will be the west side of the map, with grass and a river. Then to the east will be a desert, and then mountains. This will create a "left to right" game flow as you level up and dig deeper for more minerals.

** Scrolling
:PROPERTIES:
:CUSTOM_ID: 3-map-scrolling
:END:

I also need to make the map a bit bigger to have room for both wilderness and building. Since the map will be bigger than what's on the screen, I need to have scrolling. Normally in a "fortress style" game you'd scroll with the mouse or with dragging, but since I still have a player character walking around, I made it scroll with the player character. To center the view on the player, wherever I'm drawing to the window with:

#+begin_src js
display.draw(x, y, ch, color);
#+end_src

I need to instead /offset/ that position:

#+begin_src js
display.draw(x - player.location.x + WINDOW_WIDTH/2, 
             y - player.location.y + WINDOW_HEIGHT/2, 
             ch, color);
#+end_src

The way to think of this is in two steps:

1. Subtracting the player position moves the player to 0,0
2. Adding the width/2, height/2 moves from 0,0 to the center of the screen

A bonus would be to have a /camera/ that's separate from the /player/. Let's do that:

#+begin_src js
let camera = {x: player.location.x, y: player.location.y};

…
camera.x = player.location.x;
camera.y = player.location.y;
…
display.draw(x - camera.x + WINDOW_WIDTH/2, 
             y - camera.y + WINDOW_HEIGHT/2, 
             ch, color);
#+end_src

Ok, it's a separate object now but it's always pointed at the player. Let's change it so that it follows the player but can be behind by 2 tiles:

#+begin_src js
camera.x = clamp(camera.x, 
                 player.location.x - 2, 
                 player.location.x + 2);
camera.y = clamp(camera.y, 
                 player.location.y - 2, 
                 player.location.y + 2);
#+end_src

We can also make it stop scrolling before reaching the end of the map:

#+begin_src js
const halfwidth = VIEWWIDTH >> 1;
const halfheight = VIEWHEIGHT >> 1;
camera.x = clamp(camera.x,
                 map.bounds.left + halfwidth,
                 map.bounds.right - halfwidth+ 1);
camera.y = clamp(camera.y,
                 map.bounds.top + halfheight,
                 map.bounds.bottom - halfheight + 1);
#+end_src

I think there are more fun things that I could do but I'll leave that for later.

** Building
:PROPERTIES:
:CUSTOM_ID: 3-map-building
:END:

*** UI
:PROPERTIES:
:CUSTOM_ID: 3-building-ui-1
:END:

The generated map is only the wilderness. In this game the player will be building the rooms. I need to figure out the UI for that. If I had a /facing/ direction then the player could build in front of themselves. My first idea was to have you /pick up/ building materials and then /place/ them for building. But the keystrokes for that are annoying. If you want to build a wall on tiles 1, 2, 3:

#+begin_example
  1  2  3
  4  5  6
#+end_example

You have to first pick up the stone, then move to 4, press ~Up~ to face towards 1, press ~E~ to build, then press ~Right~ to face right, then press ~Right~ to move right, then press ~Up~ to face towards towards 2, press ~E~ to build, etc.

It'd be simpler if you didn't have to pick up the materials, but that's not the real problem. It's three keystrokes per tile. I want to reduce the number of keystrokes per tile.

The next idea was to have a build key ~B~ to switch to build mode, like vim's insert vs normal mode. In build mode you can move the cursor around freely to build things. Then press ~B~ again to go back to the player mode. What are the keys in build mode? I guess you'd have to choose what to build: ~W~ for wall, ~S~ for stockpile, etc. In the example, you would move to 4, press ~B~ to switch modes, then ~Up~ to move to 1, ~W~ for wall, ~Right~ to move to 2, ~W~ for wall, ~Right~ to move to 3, ~W~ for wall, then ~B~ to exit build mode, which would return you back to the player at 4.

This is two keystrokes per tile.

The next idea was to have commands inside build mode. In the example, you would move to 4, press ~B~ to start build mode, ~W~ to start wall-building mode, then ~Up~ to move to 1 and build a wall there, then ~Right~ to move to 2 and build there, then ~Right~ to move to 3 and build there, then ~W~ to exit wall-building mode, then ~B~ to exit build mode, which would return you back to the player at 4.

This is down to one keystroke per tile. Other modes like stockpile-drawing mode might use arrow keys to mark a rectangle instead of a line. And others like placing an object might use one or two keystrokes to choose the object, but then return you to build mode. It's looking like this:

#+begin_export html
<figure>
  <img src="screenshots/build-mode-idea-3.png" />
  <figcaption>Player and build and specialized modes</figcaption>
</figure>
#+end_export

It'd be simpler if you could directly go into wall-building mode by pressing ~W~ from the player mode. But that means you can't start a wall anywhere, but only next to where the player can walk. So I still need build mode to be able to choose where to start the wall.

Stepping back a bit, I had been starting from the "adventure mode" style movement for your player character, but I have to admit, I haven't come up with any ideas for what you'd actually /do/ in player mode. So maybe I should drop player mode, and treat build mode as the normal mode. Then you'd press the verb (~W~ for walls, ~S~ for stockpiles, ~D~ for doors, etc.) which would take you into a specialized mode for creating that type of object, and then you'd return to the main mode to move around.

I think this means I can't use the [[https://simblob.blogspot.com/2019/10/verb-noun-vs-noun-verb.html][noun-verb approach]] I wanted to try last year. Traditional roguelikes use verb-noun, where you choose the action first and then you choose the object. You might choose throw, and then choose from a list of throwable items. With noun-verb you first select an object and then you pick the action to apply. You might first choose a potion and then the action could be throw or drink. Modern games, modern programming languages, and modern UIs typically use noun-verb. For example in a text editor, you first select some text and then you pick an action like cut. Since I want a different UI depending on which verb is used, I think I have to use verb-noun instead of noun-verb.

Other thoughts: Should I switch to the mouse? Dragging a line or rectangle probably makes more sense with a mouse. But I want to see how far I can get with the keyboard. I should also take another look at [[https://dwarffortresswiki.org/index.php/DF2014:Controls][Dwarf Fortress keys]].

*** Implementation
:PROPERTIES:
:CUSTOM_ID: 3-building-implementation-1
:END:

I refactored the code a little bit, moving keyboard handling into its own module. It's starting to have a bit to deal with:

- check if the canvas if focused, display message when it is not
- key down handler
- different handlers in regular mode and wall-building mode

And I want it to do more:

- key up handler, keyboard repeat
- stockpile and other building modes
- don't handle keys if the game isn't visible on screen

For the different modes, I created a /key map/ object:

#+begin_src js
actions = {
    key_ArrowRight() { playerMoveBy(+1, 0); },
    key_ArrowLeft()  { playerMoveBy(-1, 0); },
    key_ArrowDown()  { playerMoveBy(0, +1); },
    key_ArrowUp()    { playerMoveBy(0, -1); },
};
#+end_src

In Javascript, ~{ … }~ works both as a map (Python dict) and an object. When a key ='ArrowRight'=  comes in, I can call ~actions["key_" + event.key]()~ to run the corresponding action. When I switch to wall-building mode, I'll assign a different key map to =actions=.

There's some duplicate code in there to handle the arrow keys for each of the building modes, but I'll clean that up later once I have something that works.

#+begin_export html
<figure>
  <img src="screenshots/section-3c-walls.png" />
  <figcaption>Wall building</figcaption>
</figure>
#+end_export

I implemented the beginnings of wall building but the UI is pretty rough. I need a way to /preview/ the walls that are going to be put down. That means =actions= isn't sufficient. I need to maintain state, and also hook into the rendering. Hm.

*** UI, part two
:PROPERTIES:
:CUSTOM_ID: 3-building-ui-2
:END:

I often come up with more ideas during [[https://amitp.blogspot.com/2022/05/beer-mode-and-coffee-mode.html]["beer mode"]], a relaxed state in which I am more creative. This can happen while going for a walk, or going to sleep, or taking a shower ("shower thoughts").  I had a UI thought last night: I've been focused on building /walls/ and then the /rooms/ would come later. What if the player marked the /room/, and then the walls were calculated? I looked through my notes to see what other games did:

- Dwarf Fortress: build the walls, then mark a room by expanding a region from a piece of furniture. But being Dwarf Fortress, there are also similar concepts done differently, like creating [[https://dwarffortresswiki.org/index.php/DF2014:Stockpile#Allocating_stockpiles][stockpiles]] or mining designations by marking two corners of a rectangle, or creating [[https://dwarffortresswiki.org/index.php/DF2014:Farming][farm plots]] by expanding a rectangle.
- Oxygen Not Included: build the walls, then the game automatically figures out rooms, and assigns one room type.
- RimWorld: build the walls, then the game automatically figures out rooms, and assigns one or more room types.
- Prison Architect: build the walls, then mark the room type you want, and it will give you a list of requirements for that room.
- Two Point Hospital: build the room on a grid, and place a door and needed items; walls are built automatically. Hey, this matches the idea I had last night.

Of these, I liked Two Point Hospital and Prison Architect's approaches quite a bit. They were not only easy to understand what room was going to be there, they displayed what was needed to make the room work. Prison Architect let you build the room and then then you will be told what to do to make it work. Two Point Hospital won't let you even build the room until you populate it with the needed items.

I think the rooms-first approach works better with thin walls than with thick walls. So if I decide to do this, I need to:

1. implement /thin walls/
1. change the building ui to focus on /marking rooms/ (also figure out how to allow non-rectangular rooms, and modifying existing rooms; see [[https://www.youtube.com/watch?v=hiIOWmFusCs][Two Point Hospital]]'s UI for this)
1. automatically calculate the needed walls
1. add a door marking ui

I also realized that I was so focused on building walls that I hadn't thought ahead to rooms, or what rooms are for, or how the player will interact with rooms, or whether I even need rooms. One advantage of following the roguelikedev summer tutorial is that I don't have to think about that, and I can focus on implementation. But since I'm trying to make a different style of game, I really need to be thinking farther ahead. So I took a break from implementation and started adding some ideas to the rest of this document.

I slept on this idea and decided I should implement it. Thin walls will /probably/ simplify things for my handling of rooms, even though it's a little more work to represent them. There will no longer be door /tiles/, so NPCs will never be standing in a doorway. Instead, every tile will be part of a room, or the outdoors. There will be walls between rooms, and some of those walls will have open doorways in them.

#+begin_export html
<figure>
  <img src="screenshots/section-3d-thin-walls.png" />
  <figcaption>Thin vs thick walls</figcaption>
</figure>
#+end_export

Of course now I need to go back and update the implementation.

*** Implementation, part two
:PROPERTIES:
:CUSTOM_ID: 3-building-implementation-2
:END:

Fortunately I already implemented thin walls in [[href:/x/2126-roguelike-dev/][last year's r/roguelikedev project]], so I went through that and picked out some useful functions. I represent walls as a tile location and then either ~W~ for the western edge of the tile or ~N~ for the northern edge of the tile. I don't need the south or east sides, because those are the north or west sides of the next tile over. [[href:/grids/edges/][I've written about this before]] but it was last year that I got to really put it to the test, and it worked pretty well.

I also had to update the rendering code to handle walls. For now I have only walls and doorways. While I was working on the rendering code, I ran into some inconsistencies in coordinate systems. The /tile/ coordinates are 1 step = 1 tile. The /pixel/ coordinates are 22 pixels = 1 tile (although this might vary if I want to add zooming later). If I want to draw outlines, they are 1/22 of a tile wide. The /sprite/ coordinates are 512 pixels = 1 tile. So their outlines are 23.2 pixels wide. Although it's fine for the rendering code to keep track of these things, I also want the input-handling code, and maybe other modules, to be able to draw on the screen, and that means they need to know about these scales too. I need to pick a coordinate system and stick to it.

With thin walls, I need to change the input handling code from /drawing walls/ to /drawing rooms/. To start with, the player will be able to mark a rectangle by pointing at the two corners. But I also want to support non-rectangular rooms so I might make it work by starting with a single rectangle and then adding/subtracting rectangles to it. Maybe: if you start a room in an existing room it adds a new rectangle. Maybe: press shift when starting a room to remove a rectangle.

#+begin_export html
<figure>
  <img src="screenshots/section-3e-rooms.png" />
  <figcaption>Rectangular rooms</figcaption>
</figure>
#+end_export

Minor: I've been pretty happy with my right hand on the arrows or numpad, and the left hand on the commands (~R~ for room, ~W~ for wall). But ~Enter~ is far away from both, so I think I will change that to be a left hand command.

* Field of view
:PROPERTIES:
:CUSTOM_ID: section-4
:END:

My initial thought was that field of view doesn't apply to a fortress-style game. And I don't think I want fog of war either, as I will keep things simpler for this project by having small maps. But I think I /do/ want to make it so that you only see underground areas after you excavate them. But I don't think that requires saving per-tile data. Instead, I'll have a rule that says you can see any tile if it's open, /or/ if it's adjacent to a tile that's open. As you dig into the mountain, you'll be able to see the tiles adjacent to your corridor, but no deeper.

I'm going to convert this game to be real-time instead of turn-based. I think that makes more sense for a fortress-mode style game. What's needed for this?

1. The /simulation/ needs to run every tick, not every key input.
1. The key inputs need to be queued up and processed during the tick.
1. I need to pay special attention to keyboard repeat. I /think/ the right way to handle this is to queue up key down/up events, ignore built-in keyboard repeat, keep track of key down/up. But it gets tricky. If you press and release ~J~ and then press and release ~K~ in the same tick, I want to process ~J~ because it happened first, but do I save ~K~ for the next tick, or discard it? And what happens if I press and release ~J~ and then press but hold ~K~? I've played games that get this kind of thing wrong, but I don't know the right way to handle it.

Unfortunately the current state of the game has no NPCs (friendly or enemy) and that means nothing happens every tick. So switching to real time is not going to make a visible difference right now, and it's going to be hard to spot errors. I think I should postpone it until I have NPCs.

* TODO Placing enemies
:PROPERTIES:
:CUSTOM_ID: section-5
:END:

I want to have friendly NPCs that are performing the fortress tasks (construction, digging, crafting, farming, etc.). I think the focus here will be on /pathfinding/ and /job assignment/, both algorithm-heavy problems.  Given how far beyond a reasonable scope I am, I plan to /not/ have enemy NPCs.

** Jobs, attempt 1
:PROPERTIES:
:CUSTOM_ID: 5-npc-jobs-1
:END:

NPCs need to be /assigned/ a job, and then /move/ towards the job, and then /do/ the job.

1. *Assigning*: Goblin Camp uses the Munkres-Kuhn algorithm. It's O(N³), but N is small so it's probably ok. RimWorld and Oxygen Not Included have a job priority system that the player can control. Dwarf Fortress starts out with the player manually assigning jobs, but then can hire a "manager" dwarf who will then take over that job from the player. I really like the idea of doing something manually and then outsourcing or automating it.
1. *Moving*. Pathfinding with A* is the obvious approach. But pathfinding with BFS will probably be an easier place to start. This may finally be a project where I can try out [[https://www.redblobgames.com/pathfinding/heuristics/differential.html][differential heuristics]].
1. *Doing*. A job takes some /time/ and then has some /effect/ on the world. During that time the job may involve /locking/ some objects so they can't be used by others.

The more I thought about this the more complicated it got. So I started drawing pictures. Some very smart programmers told me that smart programmers use state diagrams to think through all the cases, so I thought maybe I should try that.

#+begin_export html
<figure>
  <img src="screenshots/state-diagram-3.jpg" />
  <figcaption>State diagram attempt 3</figcaption>
</figure>
<figure>
  <img src="screenshots/state-diagram-4.jpg" />
  <figcaption>State diagram attempt 4</figcaption>
</figure>
#+end_export

Things I want to make sure I handle:

- two jobs try to move an item to two different places
- a job is cancelled while in progress
- an npc gets two jobs
- an npc dies along the way, and the job has to be reassigned

Unfortunately this conflicts with another goal I had: that each tile has at most one object. The problem is that if a job is cancelled, I need to drop the object, and that might be dropped on a tile that already has an object. What to do? Either I need to allow multiple objects on a tile (and figure out how to draw them on screen), or I need to complicate how jobs are handled. And if I allow multiple objects on a tile, a 1⨉1 stockpile can hold everything, and that isn't great. But Dwarf  Fortress allows multiple objects on a tile, and stockpiles are still useful. Hm. I asked on discord and =zendarva= said to distinguish items /stored/ on a tile, and items /dropped/ on a tile. The stored items would be limited to 1, and the dropped items would be unlimited. I like this idea.

** TODO Resources
:PROPERTIES:
:CUSTOM_ID: 5-resources
:END:

In addition to the /floor/ types (grass, desert, water) I also want to place objects on top: trees, stones, berries, gems. This will be useful for gathering jobs.


* TODO Combat
:PROPERTIES:
:CUSTOM_ID: section-6
:END:

I won't have enemy NPCs, so I don't need combat, right? But there might be some limited combat in the form of hunting for food. Given how the scope is too large, I should probably drop hunting combat from the list. If I have hunting, it could be that when the NPC reaches the animal, the animal dies and turns into food. That will put some more stress on the pathfinding system, but at least it's using an existing system instead of me having to write a new one.

* TODO Interface
:PROPERTIES:
:CUSTOM_ID: section-7
:END:

I used to write simulations and then come up with the interface, but I think that leads to parts of the simulation the player can't see. These days I instead want to start with the interface. What does the player experience? What can they see? If they can't see it, is it useful to simulate? What are the decisions they need to make, and what information do they need to make those decisions?

I realized I need to at least start thinking about this early in the project. I looked through my notes for other games I've liked: Dwarf Fortress, Rimworld, Oxygen Not Included, Factorio, Prison Architect, SimAirport, Airport CEO, Transport Tycoon, Two Point Hospital, Honey I Joined A Cult, Another Brick in the Mall, Academia School Simulator, Overcrowd.

You'll start out with a handful of colonists, and some supplies, similar to Dwarf Fortress, Rimworld, ONI. You're trying to provide food, shelter, dining, entertainment, medicine for your colonists. 

One of the things I very much want in a game of this style is gradual progression both in systems and complexity. 

- Many games gate this through a tech tree. Other progression involves number of people, the skills of those people, or advanced materials. I would like progression of some sort but I fear it may be out of scope for this project.
- I want to encourage /redesign/, not up front design. I like that Factorio has zero cost of moving something. In games with digging/mining, that's usually not undoable so it discourages redesign. Some games actively make this hard, like Airport CEO not allowing me to change a gate without shutting it down, but to shut it down I have to sit there and wait a long time before no airplanes want to use the gate.
- I want to see more systems as you progress through the game. Some games introduce too many systems early on. Prison Architect especially requires you to build lots of rooms before you can even open your prison, and then there are too few things to do later on. RimWorld seems pretty good about this, by allowing you to rely on your initial supplies and what you can find in nature. But I am not sure my game will be big enough for this to matter.
- I want to see the systems progress from low cost low return to high cost high return. For example in Oxygen Not Included the hamster wheel power is easy to set up, but doesn't provide a lot of power, and does so at high cost. Later systems like petroleum power take a lot more investment but provide much more power.
- Although I like games with indiviudal personalities and skills per colonist, I think that I'm going to not pursue that for this project. It only works for a small number of colonists, and I don't think I will have enough time to work on this anyway.
- I want to make system problems visible. In Factorio you can scan for bottlenecks, and use signals and speakers to flag problems. In Airport CEO on the other hand it seemed hard to find out what's wrong or how to fix it.
- I don't want to use grants/contracts/quests to push early progression. I feel like Prison Architect inspired other games (SimAiport, Airport CEO, Academia School Simulator) to do this. Those games required you to build too many systems up front so it seemed reasonable to have a system to help you prioritize other systems. But I'd rather do this by having fewer systems to work with early on, so that the choices are more clear.
- A lot of these games end up with me sitting around waiting for something to happen. Then they offer "VCR controls" (pause, play, fast forward) to help you deal with too many events (pause) or too few events (fast forward). It seems like a common problem, which I want solved through game design. I think Transport Tycoon and Factorio have been best at avoiding this problem, for reasons I won't write about here. But given that the scope of this project does /not/ include balance and fun, I am not planning to even try solving this problem here.
- I'd like exploration to (1) be interesting, (2) lead to different base designs. Factorio is the worst at this. Not only is exploration uninteresting, the designs aren't driven by the map. Oxygen Not Included has been pretty good about this. Not only do you find objects and creatures while exploring, the varied biomes give you a lot of variety in base layout.
- Some of these games have an inside/outside boundary. In Dwarf Fortress and RimWorld you have a colony ("inside") where you build things and a bigger world ("outside") which has encounters and raiders and traders. Factorio is all inside. Prison Architect, SimAirport, and similar games have supplies and people coming from the outside, and even have a map object (major road) to mark this.
- Some games have a lot of buildable objects, but sometimes they only fit within certain rooms. Another Brick in the Mall and Honey I Joined a Cult are examples that have /long/ lists of objects, only some applicable. I want to avoid this.  But that's easy in my case because I won't have time to make lots of objects. Oxygen Not Included, Rimworld, and others will put them into categories.
- A minor complaint about some of these games: if there's time between when I build something and when it's built, I want to be able to /configure/ the object before it's built. I don't want to have to remember to come back to configure it. I'd like to handle this properly in my project but it's a low priority compared to all the other things.

So what systems could I implement? With the big caveat that I won't time for all of them:

- Food: foraging, farming, hunting, ranching, bees/honey, cooking, preserving
- Clothing: gathered materials, cotton, wool, leather
- Furniture: floor, wooden, cloth, leather
- Tools: wooden, copper, iron, steel
- Building: wood, stone, metal
- Recreation: games, paintings, sculptures, library

Room types: bedroom, dining, kitchen, indoor storage, outdoor storage, farms, ranches, workshops of various sorts, recreation.


* TODO Items and inventory
:PROPERTIES:
:CUSTOM_ID: section-8
:END:

I have gotten rid of the player character so there's no player inventory. But the NPCs could be carrying things. And there are things on the map. I think I need to figure out /stockpiles/ and also NPC inventory. The simplest thing would be for NPCs to carry only one thing at a time, or only as much as is needed for the current job.

* TODO Ranged scrolls and targeting
:PROPERTIES:
:CUSTOM_ID: section-9
:END:

I think given how I'm biting off more than I can chew, I won't get around to combat, and I won't have scrolls or targeting. But I do want to have multiple types of jobs, including harvesting and farming, so maybe I can do that in this section.

In RimWorld and Two Point Hospital, the job objects reserve space for standing. I think that's a good idea.

* TODO Saving and loading
:PROPERTIES:
:CUSTOM_ID: section-10
:END:

I am planning to skip this. It's not hard, but it's not something I'm interested in spending my time on for this project.

* TODO Dungeon levels
:PROPERTIES:
:CUSTOM_ID: section-11
:END:

I don't plan to have z-levels. But I'm sure I will find something else to do this week.

* TODO Increasing difficulty
:PROPERTIES:
:CUSTOM_ID: section-12
:END:

I want you to have to learn more systems as you scale up. This could be more advanced tech, something to support larger populations, or something involving increased skills.

* TODO Gearing up
:PROPERTIES:
:CUSTOM_ID: section-13
:END:

Tools might qualify. A tool-making workshop could give NPCs tools, and then the tools would make them more effective.

* TODO Conclusion

#+begin_export html
<x:footer>
  Created 28 Jun 2022; &#160;
  <!-- hhmts start -->Last modified: 15 Jul 2022<!-- hhmts end -->
</x:footer>
#+end_export
